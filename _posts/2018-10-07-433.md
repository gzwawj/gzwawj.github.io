---
layout: post
title:  PHP中的自动加载
date:   2018/10/07 15:45
categories:  程序开发
tags: php 
excerpt: PHP中的自动加载  what is 自动加载？  或许你已经对自动加载有所了解。简单描述一下：自动加载就是我们在new一个class的时候，不需要手动去写require来导入这个class.php文件，程序自动帮我们加载导入进来。这是php5.1.2(好像是)版本新加入一个功能，他解放了程序员的双手，不需要手动写那么多的require，变得有那么点智能的感觉。  自动加载可以说是现代PHP框架的
comment: true
---
* content
{:top}

<h4>PHP中的自动加载</h4>

<h6>what is 自动加载？</h6>

或许你已经对自动加载有所了解。简单描述一下：自动加载就是我们在new一个class的时候，不需要手动去写require来导入这个class.php文件，程序自动帮我们加载导入进来。这是php5.1.2(好像是)版本新加入一个功能，他解放了程序员的双手，不需要手动写那么多的require，变得有那么点智能的感觉。

自动加载可以说是现代PHP框架的根基，任何牛逼的框架或者架构都会用到它，它发明出来的理由是啥呢？一个字：懒。因为项目越来愈大，相关联的类库文件越来越多，我们不可能再像小项目那样在一个文件中全部手动一个一个<code>require</code>。

<h6>如何才能自动加载呢？</h6>

PHP5.2版本更新了自动加载需要的一个魔术方法——<code>__autoload($class_name)</code>
正是这个神奇的内置魔术函数，才能让我们这些屌丝偷懒。我们来看下这个如何使用它。

<h5>1. 自动加载的原理以及__autoload的使用</h5>

自动加载的原理，就是在我们new一个class的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的<code>__autoload($class_name)</code>方法，我们new的这个<code>class_name</code> 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要<code>new class_name</code>的各种判断和划分就去require对应的路径类文件，从而实现自动加载。

我们先一步步来，看下__autoload()的自动调用，看个例子：

index.php

<pre><code class="language-php ">$db = new DB();
</code></pre>

如果我们不手动导入DB类，程序可能会报错，说找不到这个类：

<pre><code class="">Fatal error: Class 'DB' not found in D:\wamp\www\testphp\autoload\index.php on line 3
</code></pre>

那么，我们现在加入__autoload()这个方法再看看：

<pre><code class="language-php ">$db = new DB();
function __autoload($className)
{
echo $className;
exit();
}
</code></pre>

根据上面自动加载机制的描述，你分析下会输出什么？ 没错：肯定是输出：DB， 也就是我们需要new 的类的类名。所以，这个时候我们就可以在__autoload()方法里，根据需要去加载类库文件了。

index.php

<pre><code class="language-php ">$db = new DB();
function __autoload($className)
{
require $className . '.php';
}
</code></pre>

DB.php

<pre><code class="language-php ">class DB
{
public function __construct()
{
echo 'Hello DB';
}
}
</code></pre>

这样子我们就很轻松的将我们需要new 的class 全部导入了进来，这样子，我们就可以轻松的new N个class，比如：

<pre><code class="language-php ">function __autoload($className)
{
require $className . '.php';
}
$db = new DB();
$info = new Info();
$gender = new Gender();
$name = new Name();
//也是支持静态方法直接调用的
Height::test();
</code></pre>

<h5>2. spl_autoload_register的使用</h5>

小的项目，用<code>__autoload()</code>就能实现基本的自动加载了。但是如果一个项目过大，或者需要不同的自动加载来加载不同路径的文件，这个时候<code>__autoload</code>就悲剧了，原因是一个项目中仅能有一个这样的 <code>__autoload()</code> 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个<code>__autoload()</code>函数文件，否则会报致命错误，我了个大擦，那怎么办呢？放心，你想到的，PHP开发大神早已经想到。

所以<code>spl_autoload_register()</code>这样又一个牛逼函数诞生了，并且取而代之它。它执行效率更高，更灵活

先看下它如何使用吧：

当我们去<code>new</code>一个找不到的<code>class</code>时，PHP就会去自动调用<code>sql_autoload_resister</code>注册的函数，这个函数通过它的参数传进去：
<code>sql_autoload_resister($param)</code> 这个参数可以有多种形式：

<pre><code class="language-php ">sql_autoload_resister('load_function'); //函数名
sql_autoload_resister(array('load_object', 'load_function')); //类和静态方法
sql_autoload_resister('load_object::load_function'); //类和方法的静态调用

//php 5.3之后，也可以像这样支持匿名函数了。
spl_autoload_register(function($className){
if (is_file('./lib/' . $className . '.php')) {
require './lib/' . $className . '.php';
}
});
</code></pre>

index.php

<pre><code class="language-php ">function load1($className)
{
echo 1;
require $className . '.php';
}
spl_autoload_register('load1'); //将load1函数注册到自动加载队列中。
$db = new DB(); //找不到DB类，就会自动去调用刚注册的load1函数了

</code></pre>

上面就是实现了自动加载的方式，我们同样也可以用类加载的方式调用，但是必须是static方法：

<pre><code class="language-php ">class autoloading{
//必须是静态方法，不然报错
public static function load($className)
{
require $className . '.php';
}
}
//2种方法都可以
spl_autoload_register(array('autoloading','load'));
spl_autoload_register('autoloading::load');
$db = new DB(); //会自动找到
</code></pre>

需要注意的是，如果你同时使用<code>spl_autoload_register</code>和<code>__autoload</code>，<code>__autoload</code>会失效！！！ 再说了，本来就是替换它的，就一心使用<code>spl_autoload_register</code>就好了。

<h5>3. 多个spl_autoload_register的使用</h5>

<code>spl_autoload_register</code>是可以多次重复使用的，这一点正是解决了<code>__autoload</code>的短板，那么如果一个页面有多个，执行顺序是按照注册的顺序，一个一个往下找，如果找到了就停止。

我们来看下这个例子，DB.php就在本目录下，Info.php在/lib/目录下。

<pre><code class="language-php ">function load1($className)
{
echo 1;
if (is_file($className . '.php')) {
require $className . '.php';
}
}
function load2($className)
{
echo 2;
if (is_file('./app/' . $className . '.php')) {
require './app/' . $className . '.php';
}
}
function __autoload($className)
{
echo 3;
if (is_file('./lib/' . $className . '.php')) {
require './lib/' . $className . '.php';
}
}
//注册了3个
spl_autoload_register('load1');
spl_autoload_register('load2');
spl_autoload_register('__autoload');
$db = new DB(); //DB就在本目录下
$info = new Info(); //Info 在/lib/Info.php
</code></pre>

我们注册了3个自动加载函数。执行结果是啥呢？

<pre><code class="">1 Hello DB
1 2 3 Hello Info
</code></pre>

我们分析下：

<ul>
<li><code>new DB</code>的时候，就按照注册顺序，先去找<code>load1()</code>函数了，发现找到了，就停止了，所以输出<code>1 Hello Word</code></li>
<li><code>new Info</code>的时候，先是安装注册顺序，先找<code>load1()</code>, 所以输出了<code>1</code>，发现没找到，就去<code>load2()</code>里面去找，所以输出了<code>2</code>，还是没这个文件，就去<code>__autoload()</code>函数里找，所以，先输出了<code>3</code>，再输出<code>Hello Info</code></li>
</ul>

<strong>注意</strong>，前面说过，<code>spl_autoload_register</code>使用时，<code>__autoload</code>会无效，有时候，我们希望它继续有效，就可以也将它注册进来，就可以继续使用。

我们可以打印<code>spl_autoload_functions()</code>函数，来显示一共注册了多少个自动加载：

<pre><code class="language-php ">var_dump(spl_autoload_functions());
//数组的形式输出
array (size=3)
0 =&gt; string 'load1' (length=5)
1 =&gt; string 'load2' (length=5)
2 =&gt; string '__autoload' (length=10)
</code></pre>

<h5>4. spl_autoload_register自动加载+namespace命名空间 的使用</h5>

前面已经说过，自动加载现在是PHP现代框架的基石，基本都是<code>spl_autoload_register</code>来实现自动加载。<code>namespace</code>也是使用比较多的。所以<code>spl_autoload_register + namespace</code>就成为了一个主流。根据PSR-0的规范，<code>namespace</code>命名已经非常规范化，所以用<code>namespace</code>就能找到详细的路径，从而找到类文件。

我们举例子来看下：

AutoLoading\loading

<pre><code class="language-php ">&lt;!--?php &lt;br ?--&gt; namespace AutoLoading;
class loading {
public static function autoload($className)
{
//根据PSR-O的第4点 把 \ 转换层（目录风格符） DIRECTORY_SEPARATOR ,
//便于兼容Linux文件找。Windows 下（/ 和 \）是通用的
//由于namspace 很规格，所以直接很快就能找到
$fileName = str_replace('\\', DIRECTORY_SEPARATOR, DIR . '\\'. $className) . '.php';
if (is_file($fileName)) {
require $fileName;
} else {
echo $fileName . ' is not exist'; die;
}
}
}
</code></pre>

上面就是一个自动加载的核心思想方法。下面我们就来<code>spl_autoload_register</code>来注册这个函数：

index.php

<pre><code class="language-php ">&lt;!--?php &lt;br ?--&gt; //定义当前的目录绝对路径
define('DIR', dirname(__FILE__));
//加载这个文件
require DIR . '/loading.php';
//采用`命名空间`的方式注册。php 5.3 加入的
//也必须是得是static静态方法调用，然后就像加载namespace的方式调用，注意：不能使用use
spl_autoload_register("\\AutoLoading\\loading::autoload");
// 调用三个namespace类
//定位到Lib目录下的Name.php
Lib\Name::test();
//定位到App目录下Android目录下的Name.php
App\Android\Name::test();
//定位到App目录下Ios目录下的Name.php
App\Ios\Name::test();
</code></pre>

由于我们是采用PSR-O方式来定义namespace的命名的，所以很好的定位到这个文件的在哪个目录下了。很爽。对不对。

APP\Android\Name

<pre><code class="language-php ">&lt;!--?php &lt;br ?--&gt; namespace App\Android;
class Name
{
public function __construct()
{
echo __NAMESPACE__ . "
";
}
public static function test()
{
echo __NAMESPACE__ . ' static function test
';
}
}
</code></pre>

所以就会很容易找到文件，并输出：

<pre><code class="">Lib static function test
App\Android static function test
App\Ios static function test
</code></pre>

好了。基本自动加载的东西就讲完了。很实用的东西。

<h5>同命名空间下的相互调用</h5>

在平时我们使用命令空间时，有时候可能是在同一个命名空间下的2个类文件在相互调用。这个时候就要注意，在自动调用的问题了。

比如Lib\Factory.php 和 Lib\Db\MySQL.php ,我想在 Lib\Factory.php 中调用Lib\Db\MySQL.php。

怎么调用呢？以下是错误的示范：

<pre><code class="language-php ">new Lib\Db\MySQL();
//报错，提示说 D:\wamp\www\testphp\module\Lib\Lib\Db\MySQL.php is not exist
</code></pre>

看到没？这种方式是在Lib\命名空间的基础上来加载的。所以会加载2个Lib。这种方式相当于相对路径在加载。

正确的做法是，如果是在同一个命名空间下平级的2个文件。可以直接调用，不用命名空间。

<pre><code class="">new MySQL(); //直接这样就可以了。
new Db\MySQL(); //如果有个Db文件夹,就这样。
</code></pre>

还有一种方法就是使用 <code>use</code> 。使用<code>user</code>就可以带上Lib了。<code>use</code>使用的是绝对路径。

<pre><code class="language-php ">use Lib\Db\MySQL;
new MySQL();
</code></pre>

我想在 Lib\Db\MySQL.php 中调用 Lib\Register.php。怎么调用呢？

应该这样

<pre><code class="language-php ">use Lib\Register;
Register::getInstance();
</code></pre>

因为现在已经在Lib\Db这样一个命名空间了，如果你不用<code>use</code>，而是使用<code>Lib\Register::getInstance()</code>或者使用<code>Register::getInstance()</code>的话。将是在Lib\Db这个空间下进行相对路径的加载，是错误的。
    